\documentclass[10pt,fleqn,
% linksbündige, abgesetzte Formeln
reqno,a4paper]{article}
\usepackage[utf8x]{inputenc}
%\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{ngerman}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{noweb}
\pagestyle{plain}
\noweboptions{shift,german,smallcode,longchunks}%smallcode,longchunks
\usepackage[dvipsnames]{xcolor}
\usepackage{comment}
\usepackage{geometry}
%\pagestyle{noweb}\noweboptions{}
\geometry{a4paper, portrait,left=2.5cm, right=2.5cm, top=2cm, bottom=2cm}
\usepackage[T1]{fontenc}
\usepackage[tbtags, % Platzierung der Formel-Tags;% es gibt auch centertags
sumlimits,
% Platzierung der Summationsgrenzen
% (oberhalb/unterhalb)
intlimits,
% Platzierung der Integrationsgrenzen
% (oberhalb/unterhalb)
namelimits]
% Platzierung der Grenzen
% (oberhalb/unterhalb) bei Funktionen
{amsmath}
\usepackage{icomma}% für die richtige Kommadarstellung in Formeln und in Texten

% Farbige Formeln richtig einfärben über die group Umgebung
\def\mathcolor#1#{\@mathcolor{#1}}
\def\@mathcolor#1#2#3{%
	\protect\leavevmode
	\begingroup\color#1{#2}#3\endgroup
}
\newcommand{\na}{\mathcolor{blue!50!black}{a}}
\newcommand{\nx}{\mathcolor{gray}{x}}
\newcommand{\ny}{\mathcolor{gray}{y}}
\newcommand{\nz}{\mathcolor{green!30!black}{\textit{z}}}
%\newcommand{\nA}{\mathcolor{green!50!black}{A}}
\newcommand{\nw}{\mathcolor{gray}{w}}
\newcommand{\nt}{\mathcolor{gray}{t}}
\newcommand{\ntau}{\mathcolor{gray}{\tau}}
\newcommand{\nW}{\mathcolor{brown!70!black}{W}}
\newcommand{\neta}{\mathcolor{cyan!70!black}{\eta}}
\newcommand{\nnu}{\mathcolor{cyan!70!black}{u}}
\newcommand{\nsin}{\mathcolor{blue!70!black}{\sin}}
\newcommand{\ncos}{\mathcolor{blue!70!black}{\cos}}
\newcommand{\ncosh}{\mathcolor{blue!70!black}{\cosh}}
\newcommand{\nsinh}{\mathcolor{blue!70!black}{\sinh}}
\newcommand{\nexp}{\mathcolor{blue!70!black}{\exp}}
\newcommand{\nf}{\mathcolor{blue!70!black}{f}}
\newcommand{\nni}{\mathcolor{red!70!black}{i}}
\newcommand{\nm}{\mathcolor{red!70!black}{m}}
\newcommand{\nh}{\mathcolor{blue!70!black}{h}}
\newcommand{\nA}{\mathcolor{blue!70!black}{A}}
\newcommand{\dif}{\mathrm{d}}
\begin{document}
@

\input{./Deck.tex}
\tableofcontents
\newpage
\section{Einleitung}

Das Soliton ist ein Phänomen aus der Wellenmechanik, welches durch die nichtlineare Physik beschrieben werden kann.
Es sind Wellen, die über einen langen Zeitraum ihre Form und Geschwindigkeit beibehalten können. 
Die bekannteste Eigenschaft ist, dass bei einem Zusammenstoß von zwei Solitonen beide nach dem Aufeinandertreffen ihre Form und Geschwindigkeit beibehalten. 
Sinngemäß, als würden sie sich durchdringen und danach unbeschadet weiter fließen.
Wir haben es hier mit einer Wellen zu tun.
Für die mathematische Beschreibung benutzen wir die Korteweg de Vries Gleichung, damit können wir die das Phänomen simulieren. 
Hierbei beschränken wir uns auf den eindimensionalen Fall. 
In dieser Arbeit wird es hauptsächlich, um die Anwendung der Korteweg-de-Vries Gleichung auf den Fall von Solitonwellen gehen.


\section{Korteweg-de-Vries Gleichung}

\begin{align}
	\neta (\nx, \nt) _{\nt} + \sqrt{gd} \left( \neta (\nx, \nt) _{\nx} + \frac{d^2}{6}\neta (\nx, \nt) _{\nx\nx\nx}+\right.\\
	\left. +\frac{3}{2d}\neta (\nx, \nt) \neta (\nx, \nt) _{\nx} \right) = 0 \label{g:KoVri}
\end{align}
Hierbei beschreibt $ \neta (\nx, \nt) $ die Anhebung des Wassers.
Wie gewohnt beschreiben $ \nx, \nt $ die Raumkoordinate und Zeit, $ g $ ist die Fallbeschleunigung und $ d $ ist die Wassertiefe. 
Die tiefergestellten Variablen zeigen eine partielle Ableitung an $ \partial \neta / \partial \nt = \neta _{\nt}$.
Diese Gleichung werden wir nun etwas reskalieren. Zuerst fassen wir den zweiten und vierten Term zusammen und setzen den Faktor vor der Klammer zum ersten Term um.

\begin{align*}
	\frac{1}{\sqrt{gd}} \neta _{\nt} +  \neta _{\nx}\left(1 + \frac{3}{2d}\neta  \right) + \frac{d^2}{6}\neta _{\nx\nx\nx}= 0
\end{align*}
Die Gleichung multiplizieren wir mit $ 6d $ und reskalieren wir die Zeit, Raumkoordinate wie folgt:
\begin{align}
	\nt = 6\sqrt{\frac{d}{g}}\ntau, \quad \nx = d \ny \label{g:Trafo1}
\end{align}
Daraus ergibt sich folgende Gleichung
\begin{align*}
	\neta _{\ntau} +  \neta _{\ny}\left(1 + \frac{3}{2d}\neta  \right) + \neta _{\ny\ny\ny}= 0
\end{align*}
Wir machen eine Transformation von $ \neta $ nach $ \nnu $ wie folgt:
\begin{align}
	1 + \frac{3}{2d} \neta = \nnu, \quad \nnu _{\ny} = \frac{3}{2d} \neta _{\ny}, \quad \nnu _{\ntau} = \frac{3}{2d} \neta _{\ntau} \label{g:Trafo2}
\end{align}
Diese setzen wir wieder in die Ausgangsgleichung ein:
\begin{align*}
	\nnu _{\ntau} + 6\nnu \nnu _{\ny} + \nnu _{\ny \ny \ny} = 0
\end{align*}
Wir schreiben die reskalierten Variablen in der alten Notation:
\begin{align}
	\nnu (\nt, \nx) _{\nt} + 6\nnu(\nt, \nx) \nnu (\nt, \nx) _{\nx} + \nnu (\nt, \nx)_{\nx \nx \nx} = 0 \label{g:KoVrf}
\end{align}
Eine mögliche Lösung für diese Differentialgleichung für Soliton Wellen ist:
\begin{align}
	\nnu (\nx, \nt) = \frac{A}{\ncosh ^2(k\nx - w\nt -\eta _{0})} \label{g:loesung}
\end{align}
mit $ A = 2k^2, w = 4k^3 $  und $ \eta _0 $ als Anfangsanhebung. 
Die Integrale der Momente der Korteweg-de-Vries Gleichung sollen in der Zeit konstant bleiben:

\begin{align}
	\frac{\dif P_k}{\dif\nt} & = 0 \label{g:Intconst} \\
	P_0 &= \int_{-\infty}^{\infty} \nnu\; \mathrm{d}\nx = \mathrm{constant} \nonumber \\
	P_1 &= \int_{-\infty}^{\infty} \nnu^2\; \mathrm{d}\nx = \mathrm{constant} \nonumber \\
	P_2 &= \int_{-\infty}^{\infty} \left(2\nnu^3 - \left(  \nnu _{ \nx}\right)^2 \right)\;\mathrm{d}\nx = \mathrm{constant} \label{g:Int}
\end{align}

\subsection{Numerisches Lösungsverfahren: Zabuski-Kruskal Schema}
Zur Lösung der KdV Gleichung benutzen wir das Zabuski-Kruskal Schema:
\begin{align}
	\nnu =& \frac{1}{3} \left(\nnu{_{\nni-1} ^{\nm}} + \nnu{_{\nni}^{\nm}} + \nnu{_{\nni+1}^{\nm}} \right) \nonumber\\
	\nnu_{\nt}=& \frac{1}{2\Delta \nt} \left(\nnu{_{\nni}^{\nm+1}} - \nnu{_{\nni}^{\nm-1}} \right) \nonumber\\
	\nnu_{\nx} = &\frac{1}{2\Delta \nx} \left(\nnu{_{\nni+1}^{\nm}} - \nnu{_{\nni-1}^{\nm}} \right) \nonumber\\
	\nnu _{\nx \nx \nx } =& \frac{1}{2\Delta \nx^3} \left(\nnu{_{\nni+2}^{\nm}} - 2\nnu{_{\nni+1}^{\nm}} + 2\nnu{_{\nni-1}^{\nm}}- \nnu{_{\nni-2}^{\nm}} \right) \nonumber \\
	\nnu _{\nt} + 6\nnu \nnu _{\nx} + \nnu _{\nx \nx \nx} = & \frac{1}{2\Delta \nt}  \left(\nnu{_{\nni}^{\nm+1}} - \nnu{_{\nni}^{\nm-1}} \right) + \frac{1}{\Delta \nx} \left(\nnu{_{\nni-1} ^{\nm}} + \nnu{_{\nni}^{\nm}} + \nnu{_{\nni+1}^{\nm}} \right) \left(\nnu{_{\nni+1}^{\nm}} - \nnu{_{\nni-1}^{\nm}} \right) +  \nonumber \\
 &	+ \frac{1}{2\Delta \nx^3} \left(\nnu{_{\nni+2}^{\nm}} - 2\nnu{_{\nni+1}^{\nm}} + 2\nnu{_{\nni-1}^{\nm}}- \nnu{_{\nni-2}^{\nm}} \right) = 0 \label{eq:NumZabKru}
\end{align}
$ \nm $ steht für den Zeitindex und $ \nni $ steht für den Ortsindex. 
Für den ersten Zeitschritt wird ein 1. Ordnung Schemata verwendet.
Die Gleichung \ref{g:KoVrf} wird umgeschrieben:
\begin{align*}
	\frac{\dif \nnu}{\dif \nt} & = -6\nnu \nnu _{\nx} - \nnu _{\nx \nx \nx } \nonumber \\
	\nnu _{\nni} ^{1} & = \nnu _{\nni} ^{0} + \Delta \nt \left( -6\nnu \nnu _{\nx} - \nnu _{\nx \nx \nx } \right)
\end{align*}
Damit die Simulation stabil bleibt müssen wir eine geeignete Wahl von Anfangsbedingungen und Schrittgröße ermitteln. 
Die Schrittgröße lässt sich aus dem Stabilitätskriterium ableiten:
\begin{align}
 	\frac{\Delta \nt}{\Delta \nx} \left| -2u _{0} +\frac{1}{\Delta \nx^{2}} \right| < \frac{2}{3\sqrt{3}} \label{eq:StaKri}
\end{align}
Hierbei ist $ u _{0} $ das Maximum der Lösung $ \nnu (\nt,\nx) $:
\begin{align*}
  u_{0} = N(N+1) 
\end{align*}
Die Anfangsbedingungen sind für die gesamte Arbeit für $ \nt = 0 $ auf
\begin{align*}
	\nnu (0,\nx) = \frac{N(N+1)}{\ncosh^2(\nx)}
\end{align*}
gesetzt.
Weitere Simulationsparameter sind, die Größe $ G $ des Gitter, die Schrittzahl $ n $ und die Startposition $ x_0=G\cdot e $ des Solitons, wobei die Werte von $ -1 \leqslant e \leqslant 1$ gehen.
%Wir setzen noch als Parameter die Größe $ G $ des Gitters fest. 
Aus dem Stabilitätskriterium lässt sich $ \Delta \nt $ für ein beliebiges $ \Delta \nx $ abschätzen. 
Wir wählen periodische Randbedingungen aus.
Daraus erhalten wir eine Lösung die uns $ N $ Solitonen in der Simulation erzeugt, damit ist $ N $ ein weiterer Paramter zur Steuerung der Simulation für die gesamte Arbeit.
Dieses Verfahren bildet die Grundlagen für das Problem 1 im nächsten Kapitel. 
\subsection{Korteweg-de-Vries Gleichung bei variabler Tiefe} \label{sec:A2}
Für die Simulation eines Bodenprofils des Wasser führen wir die Wassertiefenfunktion $\nh (\nx) $ ein.
Dazu wird die Gleichung \ref{g:KoVrf} mit $ \nh(\nx) $ folgendermaßen  modifiziert:
\begin{align}
	\nnu (\nt, \nx) _{\nt} + \frac{6}{\nh^{7/4}(\nx)}\nnu(\nt, \nx) \nnu (\nt, \nx) _{\nx} +  \nh^{1/2}(\nx)\nnu (\nt, \nx)_{\nx \nx \nx} = 0 \label{g:KoVrf2}
\end{align}
Das Zabuski-Kruskal Schemta wird mit den gleichen ausgeführten Anfangsbedingungen und Lösungen verwendet. 
Gegeben falls muss die Schrittweite oder Startpunkt der Lösung angepasst werden, damit die Simulation stabil bleibt.

\newpage
\section{Erzeugung von Solitonwellen mit konstanter Tiefe (Problem 1)}
Wir können mittels der Variable $ N $ die Anzahl an Wellenbergen und deren Art bestimmen.
Ist $ N $ eine natürliche Zahl so erhalten wir eine N-Soliton Lösung. 
Damit die Stabilität der Lösung erhalten bleibt, muss eine kleiner Schritt $ \Delta \nx $ getan werden, womit der Zeitschritt $ \Delta \nt $ aus Gleichung \ref{eq:StaKri} abgeschätzt werden kann. 
Durch mehrere Test hat sich der Wert $ \Delta \nx = 0,1 $ als stabil ergeben.
 %Wir benutzen als Größe des Gitters den Wert $  $.
In den Diagrammen ist auf der vertikalen Achse $ \nnu $ die Anhebung und an der horizontalen Achse $ \nx $ der Ort verzeichnet. 
Im rechten oberen Bereich sind die Simulationszeit, Schrittzahl $ n $ und die Integrale $ P_{0,1,2} $ eingeblendet. 
Die Intervallgröße des Diagramms wird dynamisch durch die Formel: 
\begin{align*}
	u_{\mathrm{max}} = N(N+4,5)
\end{align*}
 bestimmt, welche durch den maximalen Wert der Soliton-Lösung, nur durch bloßem Ausprobieren erlangt worden ist.
 Wir setzen nun für die Parameter
\begin{align*}
 G = 5,5\,, N = 3\,, n = 600\,, x_0=G\cdot 0,3
\end{align*}
 fest, damit erzeugen wir eine 3-Soliton Lösung:
 
\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.4]{{Aufgabe-1/korteweg_frame1-0-0.1-5.5-3.0-0.5}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-1/korteweg_frame200-0-0.1-5.5-3.0-0.5}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-1/korteweg_frame400-0-0.1-5.5-3.0-0.5}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-1/korteweg_frame600-0-0.1-5.5-3.0-0.5}.png}  
		\caption{Eine 3-Soliton Lösung. Die Welle teilt sich in drei einzelne Solitonwellen auf. Die Integrale $ P_{0,1,2} $ verbleiben wie geplant konstant. }
	\end{center}
\end{figure}

Die Simulation bleibt stabil, die Integrale $ P_{0,1,2} $ bleiben konstant.
Die Welle teilt sich nach einer bestimmten Zeit in zwei weitere Wellen auf. 
Die Anfangslösung, eine Solitonwelle, wird in drei Solitonwellen transformiert.
Die Anzahl der Solitonwellen richtet sich nach dem Parameter $ N $. 
Wenn sich zwei Solitonwellen begegnen, vermischen sie sich kurzzeitig zu einer Welle.
Danach trennen sie sich wieder und gehen in ihrem Ursprungszustand zurück.
Dabei behalten sie ihre Bewegungsrichtung bei.
Die Wellen bleiben erhalten. 
Diese fundamentale wichtige Eigenschaft der Soliton wird durch dieses Programm deutlich wiedergegeben.

Was passiert nun wenn wir für $ N $ eine rationale Zahl einsetzen?
Demnach setzen wir für unsere weitere Untersuchung für $ N = 2,5 $ an.
Wir benutzen zudem die selben Paramter wie in der vorherigen Simulation.
%Weiterhin untersuchen wir den Fall, dass $ N $ eine rationale zahl ist.
%Hierbei setzen wir $ N = 2,5 $ und erhalten dieses Ergebnis:

\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.4]{{Aufgabe-1/korteweg_frame1-0-0.1-5.5-2.5-0.5}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-1/korteweg_frame400-0-0.1-5.5-2.5-0.5}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-1/korteweg_frame600-0-0.1-5.5-2.5-0.5}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-1/korteweg_frame800-0-0.1-5.5-2.5-0.5}.png}  
		\caption{Lösung für $ N = 2,5 $. Die Solitonwelle teilt sich wie erwartet in weitere Wellenberge auf. Hierbei verbleibt eine kleine Welle übrig, die sich nicht bewegt.}
	\end{center}
\end{figure}
\newpage
Die Lösung teilt sich in zwei Solitonwellen und in einem Wellenberg, der sich nicht bewegt, auf. 
Der unbewegte Wellenberg verhält sich wie ein Soliton, beim Aufeinandertreffen mit einer Welle vermischen sie sich und gehen danach wieder unverändert auseinander. 
Die Integrale $ P_{0,1,2} $ verbleiben einigermaßen konstant. 

\newpage
\section{Solitonwellen mit variabler Tiefe (Problem 2)}
Wir variieren nun die Wassertiefe mittels eine Wassertiefenfunktion $ \nh(\nx) $. 
Die Tiefe wird durch den Parameter $ h_0 $ charakterisiert.
Die mathematische Beschreibung geht aus dem Abschnitt \ref{sec:A2} hervor. 
%Wir benutzen eine Höhenfunktion $ \nh(x) $, welche von dem Ort abhängt. 

\subsection{$ \nh _1 (\nx) $ Unterwassererhöhung}
Wir platzieren im Wasser ein kleine Erhöhung. 
In unserer ersten Untersuchung bezeichnen wir die Wassertiefenfunktion mit $\nh_1(x)$. Sie ist folgendermaßen definiert:

\begin{align}
	\nh _1(x) = 
	\begin{cases}
		1 &\nx < 0 \\
		\frac{1+h_0+(1-h_0)\ncos(\pi \nx/L))}{2} & 0< \nx < L\\
		h_0& \nx > L
	\end{cases} \label{eq:h1}
\end{align}
Dabei haben wir einen neuen Parameter eingefügt, der sich dynamisch aus der Gittergröße $ G $ berechnet: $ L = G/6 $. 
Wir benutzen als Parameter:
\begin{align*}
\Delta \nx = 0,1\,, G = 16,4\,, N = 1,0\,, n =4400\,, h_0 = 0,5\,, x_0 = G\cdot (-0,2)
\end{align*}

% Wir benutzen eine Schrittweite von $ \Delta \nx = 0.05 $ und setzen für den Parameter $ N = 1 $ fest.
  Im Diagramm sind zum einen die Höhenfunktion $ \nh_1(x) $ in blau und die Welle $ \nnu $ in violett dargestellt. 

\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.4]{{Aufgabe-2/korteweg_frame1-1-0.1-16.4-1.0-0.5--0.2}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-2/korteweg_frame3400-1-0.1-16.4-1.0-0.5--0.2}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-2/korteweg_frame3800-1-0.1-16.4-1.0-0.5--0.2}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-2/korteweg_frame4400-1-0.1-16.4-1.0-0.5--0.2}.png}  
		\caption{Durch passieren der Erhebung wird die Welle transformiert. Es werden weitere Wellen mit höherer Amplitude erzeugt.}
	\end{center}
\end{figure}
%\newpage

Durch das Passieren des Höhenunterschieds werden nacheinander neue Wellen erzeugt, die Solitonwelle wird in Weitere transformiert, obwohl wir den Parameter auf $ N = 1 $ gesetzt haben. 
Die Amplitude der Welle wird vergrößert.
Im Gegenzug verdünnt sich deren Breite. 
Bevor sie den Rand erreichen brechen wir die Simulation ab, sonst wird durch den Sprung in der Höhenfunktion, die Simulation ungewollt gestört. 
\subsection{Abhängigkeit der Amplitude $ \nA (h_0) $ von der Tiefe $ h_0 $}
Weiterhin untersuchen wir die Abhängigkeit der Amplitude von der gewählten Höhe $ h_0 $ der Anhebung. 
Dazu verwenden wir wieder die gleichen Parameter.
Die Schrittzahl wurde anhand der gewählten $ h_0 $ gesetzt.
Je größer der Wert von $ h_0 $ ansteigt desto schneller werden Wellen erzeugt und sie bewegen sich mit größere Geschwindigkeit auf den Rand der Simulation zu. 
\newpage
\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.7]{{plotting-A-h0}.png}   
		\caption{Die Amplitude steigt linear von $ \nA(0,1) = 2,59 $ bis auf $ \nA(0,5) = 4,64 $ an und danach fällt sie wieder ab auf den ursprünglichen Wert der Amplitude $ \nA(1) = 2 $ ab.}
	\end{center}
\end{figure}

Es lässt sich aus dem Diagramm ableiten, dass die Amplitude linear ansteigt bis $ h_0 = 0,5 $ und danach wieder linear abfällt bis zur ursprünglichen Amplitude $ \nA = 2 $. 
Wir setzen für den Fit die vermutete lineare Abhängigkeit
\begin{align*}
 	\nA(h_0) = a\cdot h_0 + b
\end{align*}
auf beide Stiegungen separat an.

\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.7]{{plotting-A-h0-fit}.png}   
		\caption{Die Amplitudenfunktion $ \nA(h_0) $ hängt linear von $ h_0 $ und ähnelt der Betragsfunktion. }
	\end{center}
\end{figure}

Wir bezeichnen $ \nA_1(h_0) $ als die Funktion im Bereich von $ 0 < h_0 < 0,5 $ und $ \nA_2(h_0) $ als Funktion für das Intervall $ 0,5 < h_0 < 1 $.

\begin{align}
 	\nA_1(h_0) = 3,41h_0+3,05 \nonumber \\
 	\nA_2(h_0) =-5,45h_0+7,53 \label{eq:Amp}
\end{align}


\begin{comment}
Wenn sie auf den Rand treffen, werden sie durch den Sprung in der Wassertiefenfunktion gestört. 
Die Simulation wird unstabil. 
Um einen besseren Übergang zu erzeugen, setzen wir den linken Rand auch analytisch fort, so dass kein Sprung mehr in der Wassertiefenfunktion $ h(x) $ mehr vorkommt. 
Die neue Funktion $ h_2(x) $ ist definiert als:

\begin{align}
	\nh_2 (x) = 
	\begin{cases}
		\frac{1+h_0+(1-h_0)cos(\pi(\nx+I_l+L)/L)}{2} & I_l \leqslant  \nx \leqslant I_l+L\\
		1 &\nx < 0 \\
		\frac{1+h_0+(1-h_0)\ncos(\pi \nx/L))}{2} & 0< \nx < L\\
		h_0& \nx > L
	\end{cases}
\end{align}

$ I_l $ bezeichnet hier den linken Rand des Intervalls. 
Dadurch wird unsere Simulation an den Rändern nicht mehr stark gestört wie in den nachfolgenden Diagramm zu sehen ist.

\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.4]{{Aufgabe-2/korteweg_frame1-1-0.05-5.5-1.0-0.5-0.3}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-2/korteweg_frame4000-1-0.05-5.5-1.0-0.5-0.3}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-2/korteweg_frame8000-1-0.05-5.5-1.0-0.5-0.3}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-2/korteweg_frame12000-1-0.05-5.5-1.0-0.5-0.3}.png}  
		\caption{ }
	\end{center}
\end{figure}

\end{comment}

\subsection{$ \nh _2 (\nx) $ Beispiel eines Unterwasserhügels, exponentielle Wassertiefenfunktion}
Zur weiteren Untersuchung benutzen wir nun eine weitere Wassertiefenfunktion, den Unterwasserhügel. 

\begin{align}
\nh_2(x) = 1 - h_0 \nexp(-\nx^2/L^2 ) \label{eq:h2}
\end{align}

Wir benutzen die Werte:

\begin{align*}
 	\Delta \nx = 0,05\,, G = 10,4\,, N = 1,0\,, n = 60000\,, h_0= 0,5\,, x_0=0
\end{align*}


\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.4]{{Aufgabe-2/korteweg_frame1-3-0.05-10.4-1.0-0.5--0.4}.png}  
		\includegraphics[scale=0.4]{{Aufgabe-2/korteweg_frame15000-3-0.05-10.4-1.0-0.5--0.4}.png}
		\includegraphics[scale=0.4]{{Aufgabe-2/korteweg_frame20000-3-0.05-10.4-1.0-0.5--0.4}.png}
		\includegraphics[scale=0.4]{{Aufgabe-2/korteweg_frame60000-3-0.05-10.4-1.0-0.5--0.4}.png}
		\caption{Die Solitonwelle bewegt sich nach rechts und teilt sich beim Unterwasserhügel in weitere Wellen auf. Dabei werden einige Solitone erzeugt, die sich in die entgegengesetzte Richtung bewegen.}                 
	\end{center}
\end{figure}
Die Solitonwelle teilt sich in weitere Wellen auf, davon bewegen sich einige von rechts nach links. Ein Soliton bewegt sich langsam weiter nach rechts, dabei trifft sie auf die übrigen kleinen Wellen. 
\newpage

\section{Zusammenfassung}
Wir haben mit diesem Programm das Phänomen des Solitons untersucht. 
%Das Phänomen der Soliton, eine Welle die zeitlich konstant ist und die nach einem Zusammenstoß mit anderen Wellen wieder in ihrem ursprünglichen Zustand zurückkehrt, konnten wir durch das Simulationsprogramm aufzeigen. 
Die fundamentale Eigenschaften solch einer Welle konnten wir mit dieser Simulation aufzeigen. 
Wir konnten zeigen, dass die Wellen nach einem Zusammenstoß wieder in ihren vorherigen Zustand zurückkehrten. 
Es ist zu sehen, dass die Wellen bei ihrer Bewegung ihre Form und Geschwindigkeit beibehalten haben.  
Wir haben die Tiefe des Wasser variiert, um das Verhalten eines Solitons in dieser physikalischen Situation zu studieren und kamen auf das Ergebnis, dass die Welle sich transformierte und weitere Wellen erzeugte. 
Das Soliton konnte durch keine der gemachten Störungen zerstört werden. 
Die Eigenschaften blieben erhalten. 
Die Amplitude der Wellen wurde verändert. 
Wir haben zwei lineare Zusammenhänge zwischen der Amplitude und Tiefe finden können.
Die Form der Wassertiefenfunktion haben verändert und konnten das selbe Verhalten der Wellen beobachten.
Hierbei haben wir nur den eindimensionalem Fall betrachtet, der bestimmt mit weiteren Überlegungen und Differentialgleichungen auf Fälle höherer Dimension erweitert werden kann.
\newpage

\section{Korrekturen}
\subsection{Konstanz der Momente}
Als erstes zeigen wir, dass die Integrale der Momente der Korteweg-de-Vries Gleichung für alle Zeiten konstant ist. Es gilt
\begin{align*}
\frac{\dif P_k}{\dif\nt} & = 0
\end{align*}
Dazu nehmen wir als Anfangsbedingungen:
\begin{align}
	\nnu(\infty) &= \nnu (-\infty) = 0\nonumber \\
	\nnu_{ \nx}(\infty) &= \nnu_{ \nx} (-\infty) = 0\nonumber \\
	\nnu_{\nx \nx}(\infty) &= \nnu_{\nx \nx} (-\infty) = 0\nonumber \\
	\nnu_{\nx \nx \nx}(\infty) &= \nnu_{\nx \nx \nx} (-\infty) = 0\nonumber \\
	\nnu_{\nx \nx \nx \nx}(\infty) &= \nnu_{\nx \nx \nx \nx} (-\infty) = 0 \label{eq:ini-u}
\end{align}
Beim 1. Integral erhalten wir
\begin{align*}
\frac{\dif P_0}{\dif\nt} &= \frac{\dif }{\dif\nt}\int \nnu\; \mathrm{d}\nx = 0
\end{align*}
%\nnu _{\nt} = -6\nnu \nnu _{\nx} -\nnu _{\nx \nx \nx}
Wir benutzen die Korteweg Gleichung und setzen sie für die Zeitableitung ein
\begin{align*}
	\int \nnu _{\nt} \; \mathrm{d}\nx& = \int (-6\nnu \nnu _{\nx} -\nnu _{\nx \nx \nx}) \; \mathrm{d}\nx\\
	& = \left.-3\nnu ^2 -\nnu _{\nx \nx}\; \right|_{-\infty}^{\infty} % \\
\end{align*}
Wir benutzen die Anfangsbedingungen aus \ref{eq:ini-u}	
\begin{align*}
	%&= \left. \frac{8k^4}{\ncosh(k\nx-w\nt-\eta_0)}\; \right|_{-\infty}^{\infty} = 0
	\left.-3\nnu ^2 -\nnu _{\nx \nx}\; \right|_{-\infty}^{\infty} = 0\;.
\end{align*}
Beim 2. Integral gehen wir genauso vor
\begin{align*}
	\frac{\dif P_1}{\dif\nt} &=\frac{\dif }{\dif\nt} \int_{-\infty}^{\infty} \nnu^2\; \mathrm{d}\nx = 0 \\
	& = \int_{-\infty}^{\infty} \nnu \nnu _{\nt} \; \mathrm{d}\nx= \\
	&=\left.-2\nnu\nnu _{\nx \nx}  +(\nnu _{\nx })^2\; \right|_{-\infty}^{\infty}% \\
\end{align*}
Wir benutzen die Anfangsbedingungen aus \ref{eq:ini-u}
\begin{align*}
	%&=\left.\frac{-16k^6}{\ncosh(k\nx-w\nt-\eta_0)}\; \right|_{-\infty}^{\infty} = 0
	\left.-2\nnu\nnu _{\nx \nx}  +(\nnu _{\nx })^2\; \right|_{-\infty}^{\infty}=0\;.
\end{align*}
Beim 3. Integral ebenso
\begin{align*}
	\frac{\dif P_2}{\dif\nt} &= \frac{\dif }{\dif\nt}\int_{-\infty}^{\infty} \left(2\nnu^3 - \left(  \nnu_{\nx}\right)^2 \right)\;\mathrm{d}\nx = 0\\
	&=  \int_{-\infty}^{\infty} (-36\nnu^3\nnu_{\nx } -6\nnu^2\nnu_{\nx \nx \nx }+12\nnu_{\nx }\frac{\dif }{\dif\nx}(\nnu \nnu_{\nx }) + 2\nnu_{\nx } \nnu_{\nx \nx \nx \nx})\;\mathrm{d}\nx \\
	&= \left.-9\nnu^4-6\nnu^2\nnu_{\nx \nx} + 12\nnu_{\nx }^2\nnu+2\nnu_{\nx }\nnu_{\nx \nx \nx }-(\nnu_{\nx \nx})^2\; \right|_{-\infty}^{\infty}+12\int_{-\infty}^{\infty} \nnu \nnu_{\nx \nx} \nnu_{\nx }\dif \nx-12\int_{-\infty}^{\infty} \nnu \nnu_{\nx \nx} \nnu_{\nx }\dif \nx%\\
\end{align*}
Wir benutzen die Anfangsbedingungen aus \ref{eq:ini-u}
\begin{align*}
	%&= \left.64k^8\left(\frac{1}{(\ncosh(k\nx-w\nt-\eta_0))^4}+\frac{1}{(\ncosh(k\nx-w\nt-\eta_0))^6}\right)\; \right|_{-\infty}^{\infty} = 0
	\left.-9\nnu^4-6\nnu^2\nnu_{\nx \nx} + 12\nnu_{\nx }^2\nnu+2\nnu_{\nx }\nnu_{\nx \nx \nx }-(\nnu_{\nx \nx})^2\; \right|_{-\infty}^{\infty}=0\;.
\end{align*}
Wir untersuchen nun die Konstanz der Momente in den Simulationen. 
Numerisch berechnen wir die Integrale wie folgt:
\begin{align}
P_{\nni+1,0}& = P_{\nni,0}+\frac{1}{3} \left(\nnu{_{\nni-1} ^{\nm}} + \nnu{_{\nni}^{\nm}} + \nnu{_{\nni+1}^{\nm}} \right) \Delta \nx\\
P_{\nni+1,1}&= P_{\nni,1}+\left(\frac{1}{3} \left(\nnu{_{\nni-1} ^{\nm}} + \nnu{_{\nni}^{\nm}} + \nnu{_{\nni+1}^{\nm}} \right) \right) ^2 \Delta \nx\\
P_{\nni+1,2}&= P_{\nni,2}+\left(2\left(\frac{1}{3} \left(\nnu{_{\nni-1} ^{\nm}} + \nnu{_{\nni}^{\nm}} + \nnu{_{\nni+1}^{\nm}} \right) \right) ^3 + \left(\frac{1}{2\Delta \nx} \left(\nnu{_{\nni+1}^{\nm}} - \nnu{_{\nni-1}^{\nm}} \right) \right)^2 \right)\Delta \nx
\end{align}
Wir erhöhen die Größe des Gitters und lassen die Simulation länger laufen. 
Als Parameter wählen wir:
\begin{align*}
\Delta \nx = 0,1\,, G = 20\,, N = 2\,, n = 50000\,, x_0=G\cdot 0,3\,, \Delta \nt = 0,00028\;.
\end{align*}
Hierbei verändern wir ausschließlich den Parameter $ N=[1\,, 2\,, 2,5\,, 3] $.
\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame1-0-0.1-20.0-2.0-0.5-0.3}.png}  
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame20600-0-0.1-20.0-2.0-0.5-0.3}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame31000-0-0.1-20.0-2.0-0.5-0.3}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame50000-0-0.1-20.0-2.0-0.5-0.3}.png}
		\includegraphics[scale=0.4]{{Korrekturen/plotting-Pk-P0-N2-}.png}
		\caption{Die Solitonwelle bewegt sich nach rechts und teilt sich entsprechend $ N=2 $ in zwei weitere Wellen auf. Im letzten Diagramm sieht man deutlich bei welchen Zeitpunkten sich die Wellen wieder vereinigen. Die Werte der Integrale sinken wieder auf Null runter. }                 
	\end{center}
\end{figure}
\newpage
Das selbe Phänomen können wir bei größeren Werten vom Parameter $ N $ feststellen.
Hier für 
\begin{align*}
	N = 3
\end{align*}
\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame1-0-0.1-20.0-3.0-0.5-0.3}.png}  
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame3200-0-0.1-20.0-3.0-0.5-0.3}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame5400-0-0.1-20.0-3.0-0.5-0.3}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame50000-0-0.1-20.0-3.0-0.5-0.3}.png}
		\includegraphics[scale=0.4]{{Korrekturen/plotting-Pk-P0-N3-}.png}
		\caption{Die Solitonwelle bewegt sich nach rechts und teilt sich entsprechend $ N=3 $ in drei weitere Wellen auf. Im letzten Diagramm sieht man deutlich bei welchen Zeitpunkten sich die Wellen wieder vereinigen. Die Werte der Integrale sinken wieder auf Null runter. }                 
	\end{center}
\end{figure}
Für den Fall $ N = 2,5 $ beobachten wir fasst das selbe, im Unterschied zu dem davor, haben wir hier eine kleinere Welle die sich sehr langsam bewegt und viele winzige Wellen, die sich nach links bewegen.
\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame1-0-0.1-20.0-2.5-0.5-0.3}.png}  
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame22400-0-0.1-20.0-2.5-0.5-0.3}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame44000-0-0.1-20.0-2.5-0.5-0.3}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame50000-0-0.1-20.0-2.5-0.5-0.3}.png}
		\includegraphics[scale=0.4]{{Korrekturen/plotting-Pk-P0-N2.5-}.png}
		\caption{Die Solitonwelle bewegt sich nach rechts und teilt sich entsprechend $ N=2,5 $ in drei weitere Wellen auf. Im letzten Diagramm sieht man deutlich bei welchen Zeitpunkten sich die Wellen wieder vereinigen. Die Werte der Integrale sinken wieder auf Null runter. }                 
	\end{center}
\end{figure}
\newpage
\subsection{Wassertiefenfunktion $ \nh_1 $}
In dieser neuen Betrachtung der Wassertiefe haben die folgenden Dinge verändert: Die Größe des Gitters $ G $ erhöht, die Länge $ L $ der Stufe im Wasser und dementsprechend die Simulationszeit erhöht. 
Für die erste Wassertiefenfunktion $ \nh_1 (x) $ von Gleichung \ref{eq:h1} benutzen wir für die Höhen $ h_0= 0,2\,, 0,3 $
\begin{align*}
\Delta \nx = 0,05\,, -8<G<40\,, N = 1\,, x_0=G\cdot 0,1 \;.
\end{align*}
Für größere Höhen benutzen wir
\begin{align*}
\Delta \nx = 0,1\,, -20<G<100\,, N = 1\,, x_0=G\cdot 0,1 \;.
\end{align*}
\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame17000-1-0.05-8.0-1.0-0.2--0.1}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame20000-1-0.05-8.0-1.0-0.3--0.1}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame7000-1-0.1-20.0-1.0-0.4--0.1}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame9000-1-0.1-20.0-1.0-0.5--0.1}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame16000-1-0.1-20.0-1.0-0.6--0.1}.png}  
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame16000-1-0.1-20.0-1.0-0.7--0.1}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame16000-1-0.1-20.0-1.0-0.8--0.1}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame24000-1-0.1-20.0-1.0-0.9--0.1}.png}
		\caption{Von links nach rechts von oben nach unten, sind die Abbildungen mit aufsteigender Höhe $ h_0 $ angeordnet. Es ist immer das Endprodukt der Simulation zu sehen. Die Solitonwelle bewegt sich nach rechts und transformiert sich an der Anhöhe in ein viel größere Welle. Die Amplitude steigt sehr schnell an. Die übrig gebliebene Wellenberg teilt sich weiter in kleinere Welle auf.}                 
	\end{center}
\end{figure}
\newpage
\subsubsection{Abhängigkeit der Amplitude $ \nA (h_0) $ von der Tiefe $ h_0 $} 
Dazu verwenden wir wieder die gleichen Parameter.
Die Schrittzahl wurde anhand der gewählten $ h_0 $ gesetzt.
\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.7]{{plotting-A-h0-fit-1}.png}   
		\caption{Die Amplitude sinkt auf den Wert von $ A = 1 $ ab. Ein linearer Zusammenhang ist nur schwer zu vermuten.}
	\end{center}
\end{figure}
Für den linearen Fit erhalten wir
\begin{align}
\nA_1(h_0) = -25,23h_0 + 23,84 \label{eq:Ampk1}
\end{align}
Wenn wir die Werte für $ h_0 $ aus den Bereich  $ 0,1 < h_0 < 0,4 $ heraus nehmen und als Fit Funktion die Umkehrfunktion benutzen
\begin{align*}
	\nA_2(h_0) =  \frac{c}{h_0+e} + d
\end{align*}
bekommen wir
\begin{align}
\nA_2(h_0) =\frac{4,69}{h_0-0,17}-3,77\label{eq:Ampk2} \;.
\end{align}
\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.7]{{plotting-A-h0-fit-2}.png}   
		\caption{Die Amplitudenfunktion $ \nA(h_0) $ ist eine Umkehrfunktion ohne die Werte von$ 0,1 < h_0 < 0,4 $. Vermutlich spielt hier die Wahl der Schrittweite $ \Delta \nx $ eine große Rolle. Für die Werte $ 0,1 < h_0 < 0,4 $ haben wir eine kleinere Schrittweite $ \Delta \nx = 0,05 $ benutzt.}
	\end{center}
\end{figure}
\newpage
\subsection{Wassertiefenfunktion $ \nh_2 $}
Für die zweite Wassertiefenfunktion $ \nh_2 $ von Gleichung \ref{eq:h2} nehmen wir die gleichen Veränderungen vor wie im vorherigen Abschnitt. Als Parameter wählen wir
\begin{align*}
\Delta \nx = 0,1\,, -30<G<90\,, N = 1\,, x_0=G\cdot -0,6\,, h_0=[0,3 , 0,4 , 0,5 , 0,6] \;.
\end{align*}
\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame1-3-0.1-30.0-1.0-0.3--0.6}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame10000-3-0.1-30.0-1.0-0.3--0.6}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame30000-3-0.1-30.0-1.0-0.3--0.6}.png}\\
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame1-3-0.1-30.0-1.0-0.4--0.6}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame8400-3-0.1-30.0-1.0-0.4--0.6}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame30000-3-0.1-30.0-1.0-0.4--0.6}.png}
		\caption{Von links nach rechts von oben nach unten, sind die Abbildungen mit aufsteigender Höhe $ h_0=[0,3 , 0,4] $ angeordnet Die Solitonwelle bewegt sich nach rechts und transformiert sich an der Anhöhe in ein viel größere Welle. Die Amplitude steigt sehr schnell an. Die übrig gebliebene Wellenberg teilt sich weiter in kleinere Welle auf. Die Amplitude nimmt mit steigender Höhe zu. Nach der Überquerung der Anhöhe geht die Solitonwelle fasst zurück zu ihrer Ursprungsgröße.}
	\end{center}
\end{figure}
\begin{figure}[htp!]
	\begin{center}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame1-3-0.1-30.0-1.0-0.5--0.6}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame7200-3-0.1-30.0-1.0-0.5--0.6}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame30000-3-0.1-30.0-1.0-0.5--0.6}.png}\\
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame1-3-0.1-30.0-1.0-0.6--0.6}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame6600-3-0.1-30.0-1.0-0.6--0.6}.png}
		\includegraphics[scale=0.4]{{Korrekturen/korteweg_frame30000-3-0.1-30.0-1.0-0.6--0.6}.png}
		\caption{Von links nach rechts von oben nach unten, sind die Abbildungen mit aufsteigender Höhe $ h_0=[ 0,5 , 0,6] $ angeordnet Die Solitonwelle bewegt sich nach rechts und transformiert sich an der Anhöhe in ein viel größere Welle.}                 
	\end{center}
\end{figure}


\newpage

\section{Programm}
Das Programm wurde in der Programmiersprache Julia(\url{https://julialang.org/}) geschrieben. 
Auf den nachfolgenden Seiten können sie den gesamten Code einsehen. 
Zusätzlich ist die gesamte Arbeit mit der Software noweb geschrieben worden.
In noweb kann alles in einer Datei gespeichert werden und in Latex die einzelnen Codeabschnitte übersichtlich dargestellt werden.
Das Programm kann mit Hilfe des Befehls

\begin{verbatim}
	julia korteweg.jl 0 5000 0.1 5.5 1 0.5 1 0.3 > filled.log
\end{verbatim}

gestartet werden. 
Dabei wird die gesamte Ausgabe in die Datei filled.log geschrieben.
Die Plots wurden mit gnuplot erstellt.
Die Parameter können direkt über eingeben werden über die Kommandozeile:
\begin{verbatim}
	julia korteweg.jl p1 p2 p3 p4 p5 p6 p7 p8
\end{verbatim}

mit

\begin{itemize}
	\item p1 - Variable \verb|schalter| 
	\item p2 - Variable \verb|n|, Ende der Schleife über $ n $
	\item p3 - Variable \verb|delta_x|
	\item p4 - Variable \verb|grenze|, Größe des Gitters $ G $
	\item p5 - Variable \verb|N|, Variable $ N $
	\item p6 - Variable \verb|h0|, Tiefe des Wassers $ h_0 $
	\item p7 - Schalter für Dateioutput ja oder nein
	\item p8 - Startposition $ x_0 $
\end{itemize}



@
<<korteweg.jl>>=
#= 
Korteweg de Vries Simulationsprogramm
=#
<<PeriodicCond>>
<<Maximum>>
<<Init>>
<<h Funktion>>
<<NumCalc>>
<<IntCon>>
<<Output>>
<<Main>>
@
<<PeriodicCond>>=
function PeriodicCond(pos)# Periodische Randbedingungen
  temp1 = u[pos,scal-3]
  temp2 = u[pos,scal-2]
  u[pos,1], u[pos,2],u[pos,scal-1], u[pos,scal] =
  temp1, temp2, u[pos,3], u[pos,4]
end
@
<<Maximum>>=
function Maximum(n)
  max = 0
  if n == 1
    for i in 3:(scal-2)
      if max < u[1,i]
        max = u[1,i]
      end
    end
  else
    for i in 3:(scal-2)
      if max < u[3,i]
        max = u[3,i]
      end
    end
  end
  return max
end
@
<<Init>>=
function Init()
  global file = open("P_K-data.txt","w")
  global P0alt =0.
  global P1alt =0.
  global P2alt =0.
  global printer =Int64[0:200:parse(Int64,ARGS[2]);]# Variable zur Steuerung der 
  #Ausgabe von Dateien, alle 200 Schritt erfolgt die Ausgabe
  printer[1]=1
  global schalter=parse(Int,ARGS[1])
  global N = parse(Float64,ARGS[5]) # N- Soliton Lösung
  global delta_x = parse(Float64,ARGS[3])
  global delta_t = 2*delta_x/(3*sqrt(3)*(-2*(N*(N+1))+1/(delta_x)^2))*0.7
  global grenze = parse(Float64,ARGS[4]) # Größe des Gitters
  global L = grenze*0.3
  global h0 = parse(Float64,ARGS[6]) # Tiefe des Wassers
  global l = Int64(2)
  global pil = Int(1)
  global x = Float64[-grenze:delta_x:3*grenze;] # x Koordinate
  global scal = length(x)+4# Indexgröße von u festlegen
  global u = (zeros(Float64,3,scal)) # dimensionslose Anhebung
  for i in 3:(scal-2) #Anfangsbedinung anlegen
    u[1,i] = ((N*(N+1))/(cosh(x[i-2]+grenze*(-parse(Float64,ARGS[8]))))^2)
  end
  println("reset")
  println("#$(parse(Int,ARGS[1]))-$(parse(Float64,ARGS[2]))-\\
  $(parse(Float64,ARGS[3]))-$(parse(Float64,ARGS[4]))-\\
  $(parse(Float64,ARGS[5]))-$(parse(Float64,ARGS[6]))-\\
  $(parse(Float64,ARGS[7]))-$(parse(Float64,ARGS[8]))")
  println("# Maxmimum $(Maximum(1))")
  println("set grid")
  println("set xrange [",-grenze,":",3*grenze,"]")
  println("set yrange [",-2,":",N*(N+5)/h0,"]")#4.5 , 10.5 , 18
  println("set xlabel 'x'")
  println("set ylabel 'u'")
end
@
<<h Funktion>>=
function h(pos)
  if (schalter == 1) # h_1(x) Funktion
    if (x[pos] < 0)
      return 1
    elseif (0<=x[pos])&&(x[pos]<=L)
      return 1/2*(1+h0+(1-h0)*cos(pi*(x[pos])/L))
    else
      return h0
    end
  elseif (schalter == 2) # eine Testfunktion
    if (L<=x[pos])&&(x[pos]<=2*L)
      return 1/2*(1+h0+(1-h0)*cos(pi*(x[pos]+L)/L))
    elseif x[pos] > L
      return h0
    elseif (x[pos]<=-grenze+L)&&(x[pos]>=-grenze)
      return 1/2*(1+h0+(1-h0)*cos(pi*(x[pos]-grenze+L)/L))
    else
      return 1
    end
  elseif (schalter == 3) # h_2(x) Funktion
    return  (1-h0*exp(-x[pos]*x[pos]/(L*L)))
  else
    return 1
  end
end
@
<<NumCalc>>=
function NumCalc(n)
   for i in 3:(scal-2) # Zabuski-Kruskal Schema
      if n == 2
         u[2,i]=u[1,i] - delta_t*(((h(i-2))^(-7/4))*
         (u[1,i-1]+u[1,i]+u[1,i+1])*
         (u[1,i+1]-u[1,i-1])/delta_x+(h(i-2)^(1/2))*
         (u[1,i+2]-2*u[1,i+1]+2*u[1,i-1]-u[1,i-2])/
         (2*(delta_x)^3))
         global l=2
      else
         u[3,i]=u[1,i] - 2*delta_t*(((h(i-2))^(-7/4))*
         (u[2,i-1]+u[2,i]+u[2,i+1])*
         (u[2,i+1]-u[2,i-1])/delta_x+(h(i-2)^(1/2))*
         (u[2,i+2]-2*u[2,i+1]+2*u[2,i-1]-u[2,i-2])/
         (2*(delta_x)^3))
         global l=3
      end
   end
end
@
<<IntCon>>=
function IntCon(pos,n)
  P0=Float64(0)
  for i in 3:(scal-2)
    P0=P0+(1/3*(u[pos,i-1]+u[pos,i]+u[pos,i+1]))*delta_x
  end
  P1=Float64(0)
  for i in 3:(scal-2)
    P1=P1+((1/3*(u[pos,i-1]+u[pos,i]+u[pos,i+1]))^2)*delta_x
  end
  P2=Float64(0)
  for i in 3:(scal-2)
    P2=P2+(2*(1/3*(u[pos,i-1]+u[pos,i]+u[pos,i+1]))^3-
      ((u[pos,i+1]-u[pos,i-1])/delta_x/2)^2)*delta_x
  end
  #println("set label 3 \"P0= ",
  # trunc(P0,digits=10)," \" at screen 0.6,0.8")# Anzeige des Integrals im Diagramm
  #println("set label 2 \"P1= ",
  # trunc(P1,digits=10)," \" at screen 0.6,0.75")# Anzeige des Integrals im Diagramm
  #println("set label 1 \"P2= ",
  # trunc(P2,digits=10)," \" at screen 0.6,0.7")# Anzeige des Integrals im Diagramm
  if n>1
    #write(file,"$n $(trunc(abs(Pk[1]-P0),digits=10)) $(trunc(abs(Pk[2]-P1),digits=10)) $(trunc(abs(Pk[3]-P2),digits=10)) \n")
    write(file,"$n $(abs(Pk[1]-P0)) $(abs(Pk[2]-P1)) $(abs(Pk[3]-P2)) \n")
    #write(file,"$n $(abs(Pk[1]-P0)) $(Pk[1]) \n")
  else
    global Pk=zeros(3)
    Pk[1]=P0
    Pk[2]=P1
    Pk[3]=P2
    write(file,"$n 0 0 0 \n")
    #write(file,"$n $(Pk[1]) $(Pk[2]) $(Pk[3]) \n")
  end
end
@
<<Output>>=
function Output(pos, tsim, treal, n) # Ausgabe ins Terminal
  if (pil <= length(printer)) & ( parse(Int,ARGS[7])> 0 )
    if (n == printer[pil]) 
      #println("set term qt;")
      println("set term png; set output sprintf('korteweg_frame$n-$(parse(Int,ARGS[1]))-$(parse(Float64,ARGS[3]))-$(parse(Float64,ARGS[4]))-$(parse(Float64,ARGS[5]))-$(parse(Float64,ARGS[6]))-$(parse(Float64,ARGS[8])).png');")
      global pil = pil+1
      println("set label 5 \"sim time= ",
      trunc(tsim,digits=10)," \" at screen 0.6,0.9")# Anzeige der Zeit im Diagramm
      println("set label 6 \"n= ",n," \" at screen 0.6,0.85")
      if (schalter == 1) # Anzeige der h_1,2 Funktionen im Diagramm
      println("plot '-' w l, [-$grenze:0] -1 linecolor 3 notitle, [0:$L] \\
      -(1+$(h0)+(1-$(h0))*cos(pi*x/$(L)))/2 linecolor 3 notitle, \\
      [$L:$(5*grenze)] -$(h0) linecolor 3 notitle")
      elseif (schalter == 2)
        println("plot '-' w l, [$L:$(2*L)] (1+$(h0)+(1-$(h0))*cos((pi*(x+$L))/$L))/2-1\\
        linecolor 3 notitle, [-$(grenze):$(-grenze+L)] (1+$(h0)+\\
        (1-$(h0))*cos(pi*(x-$(grenze+L))/$L))/2-1 linecolor 3 notitle, \\
        [$(-grenze+L):$L] 1-1 linecolor 3 notitle, [$(2*L):$grenze] $(h0)-1 linecolor 3 notitle") 
      elseif (schalter == 3)
        println("plot '-' w l, [-$grenze:$(3*grenze)] -(1-$(h0)*exp(-x*x/$(L*L))) linecolor 3 notitle")
      else
        println("plot '-' w l")
      end
      global y=zeros(scal-4)
      for i in 3:(scal-2) # Werteausgabe 
        println(x[i-2]," ",u[pos,i])
      end
      println("elapsed time: 0.672879991 seconds")
    end
  end
  if n == (parse(Int,ARGS[2])) # Maximum Anzeige und Berechnung
    println("# Maxmimum $(Maximum(n))")
  end
  #close("P_K.txt")
end
@
<<Main>>=
for n in 1:(parse(Int,ARGS[2]))
   if n == 1
      global treal=0.
      global tsim=0.
      Init()
      IntCon(n,n)
      PeriodicCond(n)
      tsim=delta_t
      Output(n, tsim, treal, n)
   else
      NumCalc(n)
      PeriodicCond(l)
      if n>2 #Vertauschung der Reihen in dem Array der Anhebung
         for k in 1:scal
            temp3=u[2,k]
            u[2,k]=u[3,k]
            u[1,k]=temp3
         end
      end
      tsim=tsim+delta_t
      #println("elapsed time: 0.672879991 seconds")
      IntCon(l,n)
      Output(l, tsim, treal, n)
   end
end

@
\begin{comment}

@
@language python
from subprocess import call
#
##### Meta
'''
Programmiersprache: julia
Methoden:
    - Vertauschung von Zeilen einer (3)x(n) Matrix
    - Kommandozeilenargumente fürs Julia Programm nutzen
    - gnuplot live plot, die Daten werden sofort live angezeigt über shell pipes
    - 1. Verwendung von noweb
    - 1. Verwendung von Leo Editor als Programmierumgebung
    - Punkte im Dateiname in Latex (Quelle: https://tex.stackexchange.com/questions/10574/includegraphics-dots-in-filename)
    - PyPlot Benutzung bei Script in der Kommandozeile den Paramter -i setzen
    - 1. Verwendung von Ausgabe in Julia in Dateien, nicht nur über die Kommandozeile
'''
'''
Korrekturaufgaben vom Hernn Pikovski
  + Zeigen Sie analytisch, dass (6) gilt (berechnen Sie die Zeitableitungen in (6), setzen Sie die KdV-Gleichung und zeigen, dass (6) gilt)
  + Auch numerisch - zeigen Sie |P_k(t)-P_k(0)| aus Ihren Rechnungen in logarithmischen Skala 
    + Programmierung
    + Protokoll
  + Fuehren Sie die Simulationen im Abschnitt 3 fuer laengeren Zeit, auf einem groesserem Interval (um zB zu sehen, was mit der "Restwellen" fuer N=2,5 passiert)
    + Plot der Simulation
    + Plot der Momente
    + Protokoll
  + Im Abschnitt 4: waehlen Sie bitte L etwas groesser (groesser als die Soliton-Laenge), dabei koennen Sie die Stufe nicht in der mitte, sondern etwas links plazieren. Zeigen Sie Bilder wie Abb 3 fuer verschiedene h_0. Aehnlich fuer Abb 6 - dort soll der Bereich groesser sein, um zu sehen, on ein Soliton nach dem Huegel sich formiert.
    + Plot der Simulation für verschiedene h_0
    + Protokoll
		
Korrekturaufgaben vom Hernn Pikovski Teil 2
  +(1 Zum 6.1 : Erhaltung der Momente soll nicht fuer die Soliton-Loesung gezeigt werden, sondern fuer eine allgemeine Loesung mit (beliebigen) Anfangsbedingungen im begrenzten Bereich (so dass im Unendlichen das Feld verschwindet)
    +Protokoll	
  +(2 Abb 7-9: wie gross ist \Delta t ?
    +Protokoll
  +(3 Abb 7-9: zeichnen Sie die Integralen-Abweichungen |P_k(t)-P_k(0)| mit der logarithmishen Skala, also log|P_k(t)-P_k(0)| vs Zeit
    +gnuplot - Dias
    +Protokoll
  +(4 Geben Sie die Formeln, mit welchen die Integrale berechnet sind
    +Protokoll
  +(5 Anhand der Abb. 10 machen Sie bitte die Abb. 4-5 neu
    +Rechnung
    +Protokoll
  +(6 Abb 11: koennten Sie bitte weiter rechnen, so dass man sieht was passiert nachdem der Soliton ueber die Schwelle ist
    +Protokoll
'''
##### Historie
'''
20.2.2019
   - Testatgespräch mit Herrn Pikoski
      - Kritikpunkte:
         - keine genaue Angabe der Genauigkeit
         - Variable genau definieren mit welchen Typ sie initialisiert werden
         - das erste Integral ist dann auch nicht genau Null sondern sehr sehr klein im Vergleich zu den anderen beiden Integralen
   - Überprüfung der Genauigkeit der Integrale über genaue Variabledefinition mit Float64
   - Variablendefinition von allen float Variablen vorgenommen zu Float64
   
19.2.2019
   - Abschluss der letzten Korrekturen am Protokoll
13.2.2019
    - Teil 2 der Korrekturen beendet
4.2-7.2.2019
    - Korrekturen Pikovskis ins Programm und Protokoll eingepflegt Details siehe Abschnitt 'Korrekturen' hier und im Protokoll
10.1.2019
    - Fertigstellung des Protokolls
	
8.1.2019
    - Die letzte Aufgabe gelöst und muss nur noch ins Protokoll geschrieben werden
    - Im Programm die h(x) Funktion genau implmentiert und geplottet
    - Amplitude-h0 Plot fertig gestellt
    - die verwendeten Daten sind in der Daten-h0.txt Datei
5.1.2019
    - Programm bereinigt, alles funktioniert wieder
3.8.2018
    - Plotmethode geändert: zuerst Datei mit Daten füllen, dann gnuplot die Datei auswerten lassen
    - Fertigstellung der Plotausgabe über PyPlot
3.6.2018
    - Die Berechnung der Integrale überprüft und neu geschrieben. 
    - Aufgabe 1 vollständig protokolliert.
    - Idee: vielleicht 3d Modell bauen mit t,x,u Achsen
    - todo.cp2: Aufgabe 2 Diagramme vorbereiten und nochmal Aufgaben klären
30.5.2018
    - Lösung für Punkte im Dateinamen in Latex \includegraphics{{bild0.1-0.1}.png}
    - Lösung für die Anzeige der Nachkommastelle mittels trunc(Zahl, Nachkommastelle) Funktion
26.5.2018 
    - Bilder für die 1. Aufgabe erzeugt. Die Bilder befinden sich in dem Unterordner Aufgabe 1. 
17.5.2018 
    - Bilder werden von der laufenden Simulation in 200 Schritten abgespeichert, nebenbei läuft die Anzeige des Diagramms weiter
16.5.2018
    - T Kapitel Korteweg-de-Vries Gleichung, Numerisches Lösungsverfahren: ..., und Korteweg-de-Vries Gleichung bei variabler Tiefe geschrieben
    - todo.cp2: Überlegung ob Quellcode gleich mit einbeziehen
    - done.cp2: Bilder der Simluation für die Problemstellungen erzeugen, dazu ein bisschen Programmierarbeit nötig
20.4.2018 
    - Anfang der Einleitung
16.4.2018 
    - Bei der Compilation einen neuen Parameter gesetzt, der die Variable h0 steuert
    - ein paar Kommentare im Code gesetzt
    - die Compilation stabiler gemacht durch hinzufügen eines '&' Symbols am Ende jedes Kommandos 
    - Tests für die Abhängigkeit der Amplitude von h0 gemacht
    - offen was genau gezeigt, geplottet werden soll mit N(h0) bzw. N*(N+1) abh. h0
9.4.2018 
    - die Variable schalter erweitert 
    - die h(x) Funktion erweitert mit der exp() Funktion
    - gelungener Testlauf mit der neuen h(x) Funktion
    - überprüft ob alle Aufgaben erfüllt sind: offen: Amplitudenabhängigkeit ermitteln
    - Doku: Parameterübergabe an das julia Programm wo welcher Parameter übergeben wird beim Programm aufruf
4.4.2018
    - Umstrukturierung der noweb Datei: Einfügung des Leo Buttons
    - Erweiterung der Shell Argumente fürs julia Script 
    - Historie.log ist jetzt in der noweb Datei
    - Erweiterung des Outputs: gnuplot output in png möglich
    - Komprimierung der Dateien ausgestellt
    - Versions.conf ist jetzt Teil der noweb der Datei
28.3.2018
    - Einpflegung ins Leo Programm über die CodeFabrik.leo Datei.
    - Shell Argumente fürs julia Script eingefügt.
15.1.2018
    - Programm funktioniert wieder mit Einrückung und einen Schalter zum umschalten zwischen Problem 1 und Problem 2
'''


##### Dokumentation
## Methode zum Erzeugen des Julia Quellcodes
g.execute_shell_commands("echo '----------------Start ----------------'")
#print('start')
g.execute_shell_commands("notangle -Rkorteweg.jl korteweg-de-vries.nw > korteweg.jl")

## Methode zur Erzeugung von html Seiten

#g.execute_shell_commands("noweave -filter l2h -index -autodefs c -html korteweg-de-vries.nw > korteweg-de-vries.html &")


##### Debug

#g.execute_shell_commands("julia korteweg.jl 0 3 0.1 2.4 2 0.5 0 &")
#g.execute_shell_commands("julia korteweg.jl 0 3 0.1 2.4 2 0.5 0 | gnuplot -p &")

##### Compilation ohne Leo Editor
'''
g.execute_shell_commands("notangle -Rkorteweg.jl korteweg-de-vries.nw | julia | gnuplot -p &")

g.execute_shell_commands("notangle -Rkorteweg.jl korteweg-de-vries.nw > korteweg.jl && julia korteweg.jl 1 500000 | gnuplot -p &")

'''
##### Projekt PyPlot ohne Gnuplot plotten

#g.execute_shell_commands("julia -i korteweg.jl 0 5000 0.1 5.5 3 0.5 0 &")

## Parameterübergabeerklärung
'''
julia korteweg.jl p1 p2 p3 p4 p5 p6 p7 p8 

p1 - Variable schalter 
p2 - Ende der Schleife über n
p3 - Variable delta_x
p4 - Variable grenze, Größe des Gitters
p5 - Variable N
p6 - Variable h0, Tiefe des Wassers
p7 - Schalter für Dateioutput ja oder nein
p8 - Startposition
'''

##### Aufgabe 1

## TODO Herleitung des Stabilitätskriteriums

## N = 1

#g.execute_shell_commands("julia korteweg.jl 0 5000 0.1 5.5 1 0.5 1 0.3 | gnuplot -p &")
g.execute_shell_commands("time julia korteweg.jl 0 8000 0.1 10.5 3 0.5 1 0.3 > filled.log")

## N = 2
# sind folgende Parameter nötig delta_x = 0.1 grenze = 4.4

#g.execute_shell_commands("julia korteweg.jl 0 5000 0.1 5.5 2 0.5 1 0.3 | gnuplot -p &")
#g.execute_shell_commands("time julia korteweg.jl 0 50000 0.1 20 2 0.5 1 0.3 > filled.log")
#g.execute_shell_commands("time julia korteweg.jl 0 500 0.1 20 2 0.5 0 0.3 > filled.log")

## N = 2,5
#g.execute_shell_commands("julia korteweg.jl 0 5000 0.1 5.5 2.5 0.5 1 0.3 | gnuplot -p &")
#g.execute_shell_commands("julia korteweg.jl 0 50000 0.1 20 2.5 0.5 1 0.3 > filled.log")

## N = 3, delta_x=0.05 grenze = 5.4 ohne sleep
# bis einschließlich N = 5 reicht delta_x=0.05 und grenze = 5.4 vollkommen aus

#g.execute_shell_commands("julia korteweg.jl 0 5000 0.1 5.5 3 0.5 1 0.3 | gnuplot -p &")
#g.execute_shell_commands("time julia korteweg.jl 0 50000 0.1 20 3 0.5 1 0.3 > filled.log")

## Tests mit N als rationale Zahl, zum Teil sehr krummen Zahlen
#g.execute_shell_commands("julia korteweg.jl 0 5000 0.05 10.5 4.644674 0.5 0 0.3 | gnuplot -p &")
#g.execute_shell_commands("julia korteweg.jl 0 5000 0.05 10.5 6.644674 0.5 0 0.3 > filled.log")

##### Aufgabe 2

##Profilfunktion 1 also die originale h(x) Funktion
#g.execute_shell_commands("time julia korteweg.jl 1 9000 0.1 20 1 0.4 1 -0.2 > filled.log")


##Beschreibung für den Plot von Amplitude zur Höhe h_0
#g.execute_shell_commands("time julia korteweg.jl 1 26000 0.05 16.4 1 0.1 0 -0.2 > filled-0.1---.log")
#bei 0.1 muss man 0.05 als Schrittweite verwenden sonst explodiert die Lösung




## Profilfunktion 2 dabei den schalter auf 2 setzen
# funktioniert mit diesen Paramtern 2 500000 0.05 4.4 2 0.5 0

#g.execute_shell_commands("julia korteweg.jl 2 6000 0.05 7.5 1 0.3 0 0 > filled.log")
#g.execute_shell_commands("julia korteweg.jl 2 40000 0.05 5.5 1 0.5 0 0.3 > filled.log")

## Profilfunktion 3 mit exp(.) dabei den schalter auf 3 setzen

#g.execute_shell_commands("julia korteweg.jl 3 5000 0.05 10.4 1 0.8 0 0.5 | gnuplot -p &")
#g.execute_shell_commands("julia korteweg.jl 3 20000 0.05 10.4 1 0.5 1 0 > filled.log")
#g.execute_shell_commands("julia korteweg.jl 3 40000 0.05 10.4 1 0.5 1 -0.4 > filled.log")


# erster Test ergab bei sim time = 1.0 ein großes Soliton, für n=500000,delta_x=0.05 ,größe=10.4,N=3, h0=0.5 funktioniert
# Bei N = 3 geht es von 0 bis 0.7, dann explodiert die Lösung
# ??? # 




##### testing

#g.execute_shell_commands("julia korteweg.jl 2 6000 0.025 5.5 2 0.5 0 > filled.log")

####Korrekturen
# h0 Simulation mit rechte Grenze neu mit 5*grenze und grenze = 20
#g.execute_shell_commands("time julia korteweg.jl 1 7000 0.05 20 1 0.3 1 -0.1 > filled.log")


#h0 für die exponentielle Funktion verändern
#g.execute_shell_commands("time julia korteweg.jl 3 30000 0.1 30 1 0.6 1 -0.6 > filled.log")

'''
welche Bilder für die Korrekturen werden benutzt bzw sind die richtigen
korteweg_frame17000-1-0.05-8.0-1.0-0.2--0.1.png -0.2
korteweg_frame20000-1-0.05-8.0-1.0-0.3--0.1.png -0.3
korteweg_frame7000-1-0.1-20.0-1.0-0.4--0.1.png -0.4
korteweg_frame9000-1-0.1-20.0-1.0-0.5--0.1.png -0.5
korteweg_frame16000-1-0.1-20.0-1.0-0.6--0.1.png -0.6
korteweg_frame16000-1-0.1-20.0-1.0-0.7--0.1.png -0.7
korteweg_frame16000-1-0.1-20.0-1.0-0.8--0.1.png -0.8
korteweg_frame24000-1-0.1-20.0-1.0-0.9--0.1.png -0.9


korteweg_frame7000-1-0.1-20.0-1.0-0.4--0.1.png -0.4
korteweg_frame9000-1-0.1-20.0-1.0-0.5--0.1.png -0.5
korteweg_frame24000-1-0.1-20.0-1.0-0.9--0.1.png -0.9
korteweg_frame8800-1-0.1-20.0-1.0-0.9--0.1.png
korteweg_frame16000-1-0.1-20.0-1.0-0.8--0.1.png -0.8
korteweg_frame7600-1-0.1-20.0-1.0-0.8--0.1.png
korteweg_frame16000-1-0.1-20.0-1.0-0.7--0.1.png -0.7
korteweg_frame16000-1-0.1-20.0-1.0-0.6--0.1.png -0.6
korteweg_frame17000-1-0.05-8.0-1.0-0.2--0.1.png -0.2
korteweg_frame20000-1-0.05-8.0-1.0-0.3--0.1.png -0.3
korteweg_frame11000-1-0.1-20.0-1.0-0.6--0.2.png
korteweg_frame9000-1-0.1-20.0-1.0-0.4--0.2.png
korteweg_frame10000-1-0.1-20.0-1.0-0.5--0.2.png
'''
####
g.execute_shell_commands("echo '----------------Gnuplot Start----------------'")
g.execute_shell_commands("gnuplot filled.log -p &")
g.execute_shell_commands("echo '----------------Gnuplot Ende ----------------'")

@
@language python
##### Programm zum Start der Versionisierung des Codes
from subprocess import call
g.execute_shell_commands("notangle -RVersions.conf korteweg-de-vries.nw > Versions.conf &")
g.execute_shell_commands("/home/christian/Programme/storeBackup/bin/storeBackup.pl -f Versions.conf &")

@

@language python
##### Programm zum Start der Versionisierung des Codes
from subprocess import call

##Methode zur Erzeugung der Plotdatei für die Amplitude
g.execute_shell_commands("notangle -Rploth0.plt korteweg-de-vries.nw > ploth0.plt")

g.execute_shell_commands("gnuplot ploth0.plt -p &")

## Werte für die Fitfunktionen
#a = 3.40825     
#b= 3.04851  
#c = -5.44657     
#d = 7.52866

@

@language python
##### Programm zum Start der Versionisierung des Codes
from subprocess import call

##Methode zur Erzeugung der Plotdatei für die Amplitude
g.execute_shell_commands("notangle -RplotPk-P0.plt korteweg-de-vries.nw > plotPk-P0.plt")

g.execute_shell_commands("gnuplot plotPk-P0.plt -p &")

## Werte für die Fitfunktionen
#a = 3.40825     
#b= 3.04851  
#c = -5.44657     
#d = 7.52866

@

<<ploth0.plt>>=
reset
set grid
set yrange [0:20]
set ylabel 'A'
set term png
###
set xrange [0:1.2]
set xlabel 'h_0'
set output sprintf('plotting-A-h0-.png')
plot "h0-daten.txt" using ($1):($4) title 'Amplitude A(h_0)' lt rgb 'blue'
A_1(x) = a*x + b
A_2(x) = c/(x+e)+ d
fit [0:0.9] [0:20] A_1(x) 'h0-daten.txt' using ($1):($5) via a,b
fit [0.4:1] [0:20] A_2(x) 'h0-daten.txt' using ($1):($5) via c,d,e#
set output sprintf('plotting-A-h0-fit-1.png')
plot "h0-daten.txt" using ($1):($5) title 'Amplitude A(h_0)' lt rgb 'blue', A_1(x) lt rgb 'red'#, A_2(x) lt rgb 'brown'
set output sprintf('plotting-A-h0-fit-2.png')
plot [0.3:1.2][0:20] "h0-daten.txt" using ($1):($5) title 'Amplitude A(h_0)' lt rgb 'blue', A_2(x) lt rgb 'brown'
###
#set xrange [-0.2:1]
#set xlabel '1-h_0'
#set output sprintf('plotting-A-(1-h0).png')
#plot "h0-daten.txt" using (1-$1):($4)
###
set term qt
replot
@
<<plotPk-P0.plt>>=
reset
set grid
#set yrange [0:1000]
set yrange [0.000000000001:100000]
#set xrange [5000:100000]
set ylabel '|P_k(t)-P_k(0)|'
set logscale y
set term png
###
#set xrange [0:1.2]
set xlabel 'n'
set output sprintf('plotting-Pk-P0-test.png')
plot "P_K-data.txt" using ($1):($2) title '|P_0(t)-P_0(0)|' lt rgb 'blue', "P_K-data.txt" using ($1):($3) title '|P_1(t)-P_1(0)|' lt rgb 'red', "P_K-data.txt" using ($1):($4) title '|P_2(t)-P_2(0)|' lt rgb 'green'#
#plot "Korrekturen/P_K-data-N2.txt" using ($1):($2) title '|P_0(t)-P_0(0)|' lt rgb 'blue', "Korrekturen/P_K-data-N2.txt" using ($1):($3) title '|P_1(t)-P_1(0)|' lt rgb 'red', "Korrekturen/P_K-data-N2.txt" using ($1):($4) title '|P_2(t)-P_2(0)|' lt rgb 'green'
set term qt
replot
@


\end{comment}

\end{document}

@
